Cocos Creator 
介绍 
  一个完整的游戏开发解决方案,包括了 cocos2d-x 引擎的 JavaScript 实现,
  以及更快速开发游戏所需要的各种图形界面工具;
  包含游戏引擎、资源管理、场景编辑、游戏预览和发布等游戏开发所需的全套功能,
  并且将所有的功能和工具链都整合在了一个统一的应用程序里;
  目前支持发布游戏到Web、Android和iOS,以及点开即玩原生性能的Cocos Play手机页游平台;
  以数据驱动和组件化作为核心的游戏开发方式
  场景中的内容按照工作流分别呈现在 资源管理器、层级管理器、场景编辑器、属性检查器 四个核心面板中
说明 
  默认单位 
    时间 s,秒
    尺寸 px,像素
  项目结构 
    通过 Dashboard,创建项目之后,有特定的文件夹结构;
    初次创建并打开一个 Cocos Creator 项目后,您的项目文件夹将会包括以下结构：
    ProjectName（项目文件夹）
    ├──assets
    ├──library
    ├──local
    ├──settings
    ├──temp
    └──project.json
    assets,资源文件夹
      assets 将会用来放置您游戏中所有本地资源、脚本和第三方库文件。
      只有在 assets 目录下的内容才能显示在 资源管理器 中。
      assets 中的每个文件在导入项目后都会生成一个相同名字的 .meta 文件,
      用于存储该文件作为资源导入后的信息和与其他资源的关联。
      一些第三方工具生成的工程或设计原文件, 如 Photoshop 的 .psd 文件,
      可以选择放在 assets 外面来管理。
    library,资源库
      library 是将 assets 中的资源导入后生成的,
      在这里文件的结构和资源的格式将被处理成最终游戏发布时需要的形式。
      若您使用版本控制系统管理您的项目,这个文件夹是不需要进入版本控制的。
      当 library 丢失或损坏的时候,只要删除整个 library 文件夹再打开项目,就会重新生成资源库。
    local,本地设置
      local 文件夹中包含该项目的本地设置,包括编辑器面板布局,窗口大小,位置等信息。
      您不需要关心这里的内容,只要按照您的习惯设置编辑器布局,这些就会自动保存在这个文件夹。
      一般 local 也不需要进入版本控制。
    settings,项目设置
      settings 里保存项目相关的设置,如 构建发布 菜单里的包名、场景和平台选择等。
      这些设置需要和项目一起进行版本控制。
    project.json
      project.json 文件和 assets 文件夹一起,作为验证 Cocos Creator 项目合法性的标志。
      只有包括了这两个内容的文件夹才能作为 Cocos Creator 项目打开。
      而 project.json 本身目前只用来规定当前使用的引擎类型和插件存储位置,不需要用户关心其内容。
      这个文件也应该纳入版本控制。
  术语
组件化开发 
  PS：脚本以组件的形式添加到节点上
  脚本的一般形式
    cc.Class({
      extends: cc.Component, // 继承至cc.Component
      properties: {     // 定义引用的节点或自定义的属性
        aoo : {         // 节点引用的完整写法
           default: null,      // 节点的默认值
           url: cc.Texture2D,  // 可选,
           serializable: true, // 可选,默认为true 
           visible: true,      // 可选,默认为true
           displayName: 'Foo', // 可选,
           readonly: false,    // 可选,默认为false
          //  ...
        },
        boo : cc.Label, // 表明节点的类别,节点引用的简写方式
        coo : 'hello world', // 自定义属性
        // 当属性为字符串、数值等非引用类型时,可忽略其类型声明
        
      },
      
      onLoad: function () {  // 场景加载后自动执行,一般用于放置初始化代码
        // 函数中this表示..,
        // properties也处于其原型链上,也会去properties上查找属性方法
        var aoo = this.boo.parent; // 获取boo节点的父节点
        this.posAR.string = 'abc'; //  设置文本节点的文本值
      },
      
      update: function (dt) {  // 循环执行,约15ms调用一次
        
      },
    });
API 
  节点相关 
    ◆节点类型
    cc.Label  文本
    cc.Node   节点
    cc.SpriteFrame 图片资源
    ◆节点属性
    ccNode.string  可读写,节点的文本值
    ccNode.parent  节点的父节点
    ◆创建节点
    cc.instantiate(prefa)  返回通过预置资源创建的节点
Cocos2d-js API
--------------------------------------------------------------------------------
菜单栏
toolbar,工具栏 
  PS：包括了场景编辑工具和预览游戏时的操作按钮;
    左边为场景编辑的相关工具,如移动、旋转、缩放等工具按钮
    右边显示了远程测试和调试时使用访问地址,以及连接中的设备数;
    位于编辑器主窗口的正上方,包含了五组控制按钮或信息,
    用来为特定面板提供编辑功能或方便我们实施工作流。
  transform tool,选择变换工具 
    为 场景编辑器 提供编辑节点变换属性（位置、旋转、缩放、尺寸）的功能
  preview,预览
    运行预览：点击后在浏览器中运行当前编辑的场景。
    刷新设备：在所有正在连接本机预览游戏的设备上重新加载当前场景
      （包括本机浏览器和其他链接本机的移动端设备）。
  preview url
    这里显示运行 Cocos Creator 的桌面电脑的局域网地址,
    连接同一局域网的移动设备可以访问这个地址来预览和调试游戏。
  open project,打开项目文件夹
    在操作系统的文件管理器（Explorer 或 Finder）打开项目所在的文件夹。  
资源管理器：访问和管理项目资源的工作区域
  PS：显示了项目资源文件夹「assets」中的所有资源,
    包括项目中所有的资源和脚本文件;为每个资源分配UUID,解决改名和移动时的索引问题;
    项目中只有 assets 目录下的资源才会被 Cocos Creator 导入项目并进行管理;
    图片文件导入后会经过简单的处理成texture类型资源,可将其拖拽到场景或组件属性中使用;
    资源列表中的文件会隐藏扩展名,而以图标指示文件或资源的类型;
    图片资源:目前包括 jpg, png 等图像文件,图标会显示为图片的缩略图
    拖拽移动放置资源;
    删除资源是不可撤销的操作,无法从回收站（Windows）或废纸篓（Mac）找回
  目前可以在资源管理器中创建的资源：
    PS：点击创建按钮,弹出创建资源菜单;点击其中的项目就会在当前选中的位置新建相应资源;
    文件夹   在资源管理器中以folder图标显示,除了文件夹之外列表中显示的都是资源文件
    脚本文件 通过编辑这些脚本为添加组件功能和游戏逻辑
    场景     双击可打开的场景文件,打开场景文件后才能继续进行内容创作和生产
    动画剪辑 
  Scene 游戏场景 
    PS：Scene是开发时组织游戏内容的中心,也是呈现给玩家所有游戏内容的载体。
      一般包括：Sprite、Label、角色及游戏逻辑脚本「以组件形式附加在场景节点上」;
      当运行游戏时,就会载入Scene,载入后就会自动运行所包含组件的游戏脚本,
      实现各种各样开发者设置的逻辑功能;
      除了资源以外,Scene是一切内容创作的基础;
    创建、打开Scene
      在资源管理器中选择目录确定创建的位置;
      点击左上角的加号-Scene,创建Scene
      双击Scene,在场景编辑器和层级编辑器中打开该场景
    Canvas 
      Scene就是以Canvas为基础支持的;
      Canvas可以被称为画布节点或渲染根节点,场景图像都会放在Canvas节点下
    修改场景资源自动释放策略
      PS：从当前场景切换到下一个场景时,若当前场景不自动释放资源,
        则该场景中直接或间接引用到的所有资源（脚本动态加载的不算）,默认都不主动释放。
        反之若启用了自动释放,则这些引用到的资源默认都会自动释放。
        若项目中的场景很多,随着新场景的切换,内存占用就会不断上升。
      配置自动释放
        除了使用 cc.loader.release 等API来精确释放资源外,还可使用场景的自动释放功能;
        在资源管理器中选中场景,在属性检查器中勾选“自动释放资源”选项「该项默认关闭」
      已知问题：
        粒子系统的 plist 所引用的贴图不会被自动释放。
        若要自动释放粒子贴图,请从 plist 中移除贴图信息,改用粒子组件的 Texture 属性来指定贴图。
      防止特定资源被自动释放
        某个场景的启用资源自动释放后,若脚本中保存了该场景的资源引用,
        当场景切换后,这些资源就会变成非法的,很容易出错。
        或者若调用 cc.game.addPersistRootNode 方法让某个该场景中的节点保留到下一个场景,
        但这个节点及其子节点用到的所有资源也还是会被同时释放,导致下个场景不能再正确访问这些资源;
        为了让这部分资源在场景切换时不被释放,可以使用 cc.loader.setAutoRelease 或者 cc.loader.setAutoReleaseRecursively 来保留这些资源。
      修改场景加载策略
        选中指定场景,在 属性检查器 中看到“延迟加载资源”选项,该项默认关闭。
        加载场景时,若这个选项关闭,则这个场景直接或间接递归依赖的所有资源都将被加载,
        全部加载完成后才会触发场景切换。
      延迟加载资源
        加载场景时,若选项开启,
        则该场景直接或间接依赖的所有贴图、粒子和声音都将被延迟到场景切换后才加载,
        使场景切换速度极大提升。
        同时,玩家进入场景后可能会看到一些资源陆续显示出来,
        并且激活新界面时也可能会看到界面中的元素陆续显示出来,因此这种加载方式更适合网页游戏。
        使用这种加载方式后,为了能在场景中更快地显示需要的资源,
        建议一开始就让场景中暂时不需要显示的渲染组件（如 Sprite）保持非激活状态。
        Spine 和 TiledMap 依赖的资源永远都不会被延迟加载。      
  Texture, 图像资源 
    PS：图像资源又经常被称作贴图、图片,是游戏中绝大部分图像渲染的数据源。
      图像资源一般由图像处理软件「如PS」制作而成并输出成cc可以使用的文件格式,
      目前包括 JPG 和 PNG 两种。
      在 资源管理器 中选中图像资源后,属性检查器 下方会显示该图片的缩略图。
      目前图像资源的属性设置功能还没有完善,请不要在 属性检查器 手动修改图像资源的属性设置。
    SpriteFrame 资源类型
      每个图像资源导入后编辑器会自动在它下面创建同名的 SpriteFrame 资源。
      SpriteFrame 是核心渲染组件 Sprite 所使用的资源,
      设置或替换 Sprite 组件中的 spriteFrame 属性,就可以切换显示的图像。
      Atlas类型:包含多个 SpriteFrame 的图集资源
    使用 SpriteFrame
      直接将 SpriteFrame 或图像资源从 资源管理器 中拖拽到 层级管理器 或 场景编辑器 中,
      就可直接用所选的图像在场景中创建 Sprite 节点。
      之后拖拽其他的 SpriteFrame 或图像资源到该 Sprite 组件的 Sprite Frame 属性栏中,
      来切换该 Sprite 显示的图像。
      在 动画编辑器 中也可以拖拽 SpriteFrame 资源到已创建好的 Sprite Frame 动画轨道上;
    性能优化注意事项
      使用单独存在的 Texture 作为 Sprite 资源,在预览和发布游戏时,
      将无法对这些 Sprite 进行批量渲染优化的操作。
      目前编辑器不支持转换原有的单张 Texture 引用到 Atlas 里的 SpriteFrame 引用,
      所以在开发正式项目时,应该尽早把需要使用的图片合成 Atlas（图集）,
      并通过 Atlas 里的 SpriteFrame 引用使用。
    Atlas,图集资源
      PS：也称作 Sprite Sheet,是游戏开发中常见的一种美术资源。
        图集是通过专门的工具将多张图片合并成一张大图,并通过 plist 等格式的文件索引的资源。
        可供 Cocos Creator 使用的图集资源由 plist 和 png 文件组成。
        在游戏中使用多张图片合成的图集作为美术资源,有以下优势：
        合成图集时会去除每张图片周围的空白区域,加上可以在整体上实施各种优化算法,合成图集后可以大大减少游戏包体和内存占用
        多个 Sprite 如果渲染的是来自同一张图集的图片时,这些 Sprite 可以使用同一个渲染批次来处理,大大减少 CPU 的运算时间,提高运行效率。
      制作图集资源
        要生成图集,首先您应该准备好一组原始图片：
        接下来可以使用专门的软件生成图集,我们推荐的图集制作软件包括：
        TexturePacker、 Zwoptex
        使用这些软件生成图集时请选择 cocos2d-x 格式的 plist 文件。
        最终得到的图集文件是同名的 plist 和 png。
      导入图集资源
        将的 plist 和 png 文件同时拖拽到 资源管理器 中,
        就可以生成可以在编辑器和脚本中使用的图集资源了。
      Atlas 和 SpriteFrame
        导入图集资源后,Atlas里包含了很多类型为 SpriteFrame 的子资源,
        每个子资源都是可以单独使用和引用的图片。
      碎图转图集和拆分合并图集工作流程
        在项目原型阶段或生产初期,美术资源的内容和结构变化都会比较频繁,
        我们通常会直接使用碎图（也就是多个单独的图片）来搭建场景和制作 UI。
        在之后为了优化性能和节约包体,需要将碎图合并成图集,或者将图集中的内容进行拆分或合并。
      目前我们提供了一个简单的小工具来完成场景中对图片资源引用从碎图或老图集到新图集的重定向。
        生成新图集：不管是从碎图合并,还是将原来的图集重新拆分或合并,您都需要先使用 TexturePacker 生成完整的新图集。然后将新图集导入到项目资源文件夹中。
        双击打开您需要重定向资源引用的场景或 Prefab
        点击主菜单的「开发者->在当前场景使用指定图集替换 spriteFrame...」,在打开的对话框里选择您新生成的图集,等待替换操作完成。（如果新图集有多张,应该重复这一步直到所有相关新图集都替换完毕） 4.如果您有多个场景或 prefab,需要重复执行 2-3 步,遍历每个相关的场景或 Prefab
        确认所有相关图片资源的引用都已经替换成了新图集后,现在可以删除原有的碎图或旧图集了。      
    Auto_Atlas,自动图集资源
      cc自带的合图功能,可将指定的一系列碎图打包成一张大图,
      具体作用和 Texture Packer 的功能很相近。
      创建自动图集资源
        右键 -> 新建 -> 自动图集配置,点击新建一个类似 AutoAtlas.pac 的资源。
        自动图集资源 将会以当前文件夹下的所有 SpriteFrame 作为碎图资源,
        以后会增加其他的选择碎图资源的方式。 
        如果碎图资源 SpriteFrame 有进行配置过,在打包后重新生成的 SpriteFrame 将会保留这些配置。
      配置自动图集资源
        PS：在资源管理器中选中一个 自动图集资源 后,
          属性检查器 面板将会显示 自动图集资源 的所有可配置项。
        Max Width  单张图集最大宽度
        Max Height 单张图集最大高度
        Padding    图集中碎图之间的间距
        Allow Rotation 是否允许旋转碎图
        Force Squared  是否强制将图集长宽大小设置成正方形
        PowerOfTwo     是否将图集长宽大小设置为二次方倍数
        Heuristices    图集打包策略
          BestShortSideFit
          BestLongSideFit,
          BestAreaFit
          BottomLeftRule
          ContactPointRule
        Format 图集图片生成格式 「可选的格式有png, jpg, webp」
          配置完成后可以点击 预览 按钮来预览打包的结果,
          按照当前自动图集配置生成的相关结果将会展示在 属性检查器 下面的区域。
          需要注意的是每次配置过后,需要重新点击 预览 才会重新生成预览信息。
        结果：
        Packed Textures, 显示打包后的图集图片以及图片相关的信息,如果会生成的图片有多张,则会往下在 属性检查器 中列出来。
        Unpacked Textures,显示不能打包进图集的碎图资源,造成的原因有可能是这些碎图资源的大小比图集资源的大小还大导致的,这时候可能需要调整下图集的配置或者碎图的大小了。
      生成图集
        预览项目或者在 Cocos Creator 中使用碎图的时候都是直接使用的碎图资源,
        在 构建项目 这一步才会真正生成图集到项目中。 
        生成的大图将会放在 构建目录 下的 res/raw-assets 相对于项目中 assets 目录结构下的对应的目录中,
        以 AutoAtlas-xx.png 结构命名。 
        生成项目后可以到对应的目录下检查对应的图集资源是否生成成功了。
  创建、添加脚本 
    通常在assets下创建一个script文件夹来存放JS脚本
    脚本名称就是组件的名称,且大小写敏感
    
    编写脚本 
      打开的脚本里已经有了预先设置好的一些代码块,这些代码就是编写一个组件脚本所需的结构。
      具有这样结构的脚本就是 Cocos Creator 中的组件（Component）,
      他们能够挂载到场景中的节点上,提供控制节点的各种功能。
        properties: {
            // 主角跳跃高度
            jumpHeight: 0,
            // 主角跳跃持续时间
            jumpDuration: 0,
            // 最大移动速度
            maxMoveSpeed: 0,
            // 加速度
            accel: 0,
        },
        代码中不需关心这些数值是多少,因为之后会直接在属性检查器中设置这些数值,
    把脚本组件添加到需要控制的节点上 
      在 层级编辑器 中选中对应的节点,然后在 属性检查器 中点击 添加组件 按钮,
      选择 添加用户脚本组件 对应的JS脚本,为节点添加 JS脚本组件。    
  LabelAtlas,艺术数字资源 
    一种用户自定义的资源,它可以用来配置艺术数字字体的属性。
    创建艺术数字资源
      右键 -> 新建 -> 艺术数字配置,新建一个类似 LabelAtlas.labelatlas 的资源。
      艺术数字资源 在使用之前需要进行一些配置,
      比如关联渲染的图片资源,设置每一个字符的宽高和起始字符信息。
    配置艺术数字资源
      选中 艺术数字资源 后,在属性检查器中进行配置
      配置完成后需要点击 属性检查器 右上角的绿色的打勾按钮来保存设置。
      Raw Texture File 指定渲染图片
      Item Width       指定每一个字符的宽度
      Item Height      指定每一个字符的高度
      Start Char       指定艺术数字字体里面的第一个字符
        如果字符是 Space,也需要在这个属性里面输入空格字符
    使用艺术数字资源
      新建一个 Label 组件,然后把新建好的艺术数字资源拖到 Label 组件的 Font 属性即可。
  Prefab 预制资源 
    创建及使用Prefab
      将在场景中编辑好节点从 层级管理器 拖到 资源管理器,即创建出了一个预制资源,
      在脚本中引用Prefab后,就可以动态生成节点内容了
    保存预制 
      在场景中修改了预制实例后,在 属性检查器 中直接点击 保存,即可保存对应的预制资源：
    还原预制 
      在场景中修改了预制实例后,在 属性检查器 中直接点击 回退,即可将预制对象还原为资源中的状态：
    自动同步和手动同步
      每个场景中的预制实例都可以选择要自动同步和还是手动同步。
      设为手动同步时,当预制对应的原始资源被修改后,场景中的预制实例不会同步刷新,
      只有在用户手动还原预制时才会刷新。
      设为自动同步时,该预制实例会自动和原始资源保持同步。
      注意,为了保持引擎的精简,自动同步的预制实例有如下限制：
      
      场景中的预制实例仅能修改预制的根节点自身的 name、active、position 和 rotation 属性,
      其它子节点和所有组件都必须和原始资源保持一致,否则编辑器会询问是要撤销修改还是要更新原始资源。
      自动同步的预制中的组件无法引用该预制外的其它对象,否则编辑器会弹出提示。
      自动同步的预制外面的组件只能引用该预制的根节点,无法引用组件和子节点,否则编辑器会弹出提示。
      这些限制都仅影响编辑器操作,运行时不影响。
    将预制还原成普通节点
      从 资源管理器 中删除一个预制资源后,你可以将场景中对应的预制实例还原成普通节点。
      方法是选中预制实例,然后点击菜单 节点 > 还原成普通节点。      
  字体资源
    PS：cc中可以使用三类字体资源：系统字体,动态字体和位图字体。
      其中系统字体是通过调用游戏运行平台自带的系统字体来渲染文字,
      不需要用户在项目中添加任何相关资源。
      字体资源需要通过 Label 组件来渲染
    动态字体
      支持 TTF 格式的动态字体。
      只要将扩展名为 TTF 的字体文件拖拽到 资源管理器 中,即可完成字体资源的导入。
    位图字体
      位图字体由 fnt 格式的字体文件和一张 png 图片组成,
      fnt 文件提供了对每一个字符小图的索引。
      这种格式的字体可以由专门的软件生成,请参考位图字体制作工具。
      在导入位图字体时,请务必将 fnt 文件和 png 文件同时拖拽到 资源管理器 中。
      注意 为了提高资源管理效率,建议将导入的 fnt 和 png 文件存放在单独的目录下,
      不要和其他资源混在一起。
    关联字体资源
      将字体资源拖拽到创建的 Label 组件中的 File 属性栏中
      这时场景中的字体会立刻用刚才指定的字体资源进行渲染。
      切换字体文件时,Label 组件的其他属性不受影响。
      如果要恢复使用系统字体,可以点击 Use System Font 的属性复选框,
      来清除 File 属性中指定的字体文件。
      另外一种快捷使用指定资源创建字体节点的方法,
      是直接从 资源管理器 中拖拽字体文件（TTF 或位图字体都可以）到 层级管理器 中。
      使用拖拽方式创建的文字节点会自动使用拖拽的字体资源来设置 Label 组件的 File 属性。
    位图字体合并渲染
      如果位图字体使用的贴图和其他 Sprite 使用的贴图是同一张,
      而且位图字体和 Sprite 之间没有插入使用其他贴图的渲染对象时,
      位图字体就可以和 Sprite 合并渲染批次。
      在放置位图字体资源时,请把 .fnt 文件、.png 文件和 Sprite 所使用的贴图文件放在一个文件夹下,
      然后参考 自动图集工作流程 将位图字体的贴图和 Sprite 使用的贴图打包成一个图集,
      即可在原生和 WebGL 渲染环境下自动享受位图字体合并渲染的性能提升。
  ParticleSystem,粒子资源
    将 Cocos2d 支持的粒子 .plist 文件直接放到工程资源目录下。
    在场景中添加粒子系统
      
      方法一,从 资源管理器 里将粒子资源直接拖到 层级管理器：
      
      drag-to-hierarchy
      
      方法二,从 资源管理器 里将粒子资源直接拖到 场景编辑器：
      
      drag-to-scene
      
      方法三,在已有节点上添加一个 粒子系统（ParticleSystem） 组件,从 资源管理器 里将粒子资源直接赋给组件的 File 属性：
      
      drag-to-inspector
      
      注意：不支持 .plist 文件中的 sourcePosition 属性的导入。
      
      在项目中的存放
      
      为了提高资源管理效率,建议将导入的 plist 和 png （如果有使用贴图）文件存放在单独的目录下,不要和其他资源混在一起。
      
      渲染错误解决方法
      
      粒子使用的 png 贴图文件或 base64 格式的内置图片文件可能会有不正确的预乘信息,导致渲染出的粒子不能正确显示透明区域。如果出现这种情况,请手动修改粒子 plist 文件中的 blendFuncSource 属性到下面的值：
      
          <key>blendFuncSource</key>
          <integer>770</integer>
      
  .meta 资源配置文件
    PS：所有 assets 路径下的资源都会在导入时生成一份 资源配置文件「.meta」,
      这份配置文件提供了该资源在项目中的唯一标识（uuid）,
      以及其他的一些配置信息（如图集中的小图引用,贴图资源的裁剪数据等）;
      在编辑器中管理资源时,meta 文件是不可见的,
      对资源的任意删除、改名、移动操作,都会由编辑器自动同步相应的 meta 文件,
      确保 uuid 的引用不会丢失和错乱。
      注意在编辑器外部的文件系统中（Explorer,Finder）对资源文件进行删除、改名、移动时,
      必须同步处理相应的 meta 文件。
      资源文件和其对应的 meta 文件应该保持在同一个目录下,而且文件名相同。
    处理无法匹配的资源配置文件
      若您在编辑器外部的文件系统「Explorer,Finder等」中进行了资源文件的移动或重命名,
      而没有同步移动或重命名 meta 文件时,会导致编辑器将改名或移动的资源当做新的资源导入,
      可能会出现场景和组件中对该资源（包括脚本）的引用丢失。
      在编辑器发现有未同步的资源配置文件时,会弹窗警告用户,并列出所有不匹配的 meta 文件。
      这时无法正确匹配的资源配置文件会从项目资源路径（asset）中移除,并自动备份到 temp 路径下。
      若您希望恢复这些资源的引用,请将备份的 meta 文件复制到已经移动过的资源文件同一路径下,
      并保证资源文件和 meta 文件的文件名相同。
      注意编辑器在处理资源改名和移动时会生成新的 meta 文件,
      这些新生成的 meta 文件可以在恢复备份的 meta 后安全删除。
node_library,控件库
  PS：预设控件的仓库,可以通过拖拽方式添加到场景中;
    且可将自定义的预制资源「prefab」添加到控件库,方便再次使用;
    简单直接的可视化控件仓库,拖拽控件到场景编辑器或层级管理器中,快速完成预设控件的创建;
    控件库 里包含的控件内容和主菜单中的 节点 菜单里可以添加的预设节点是一致的,
    但通过控件库创建新节点更加方便快捷。
  内置控件： 编辑器内置的预设节点
    可快速生成包括默认资源的精灵（Sprite）、包含背景图和文字标题的按钮（Button）
    以及已经配置好内容和滚动条的滚动视图（ScrollView）等
  自定义控件： 收集用户自己建立的预制资源「Prefab」,方便重复多次创建和使用。
    从 资源管理器 中拖拽相应的预制资源（Prefab）到自定义控件分页,即可完成创建
场景编辑器：用来展示和编辑场景中可视内容的工作区域
  PS：所见即所得的场景搭建工作都依靠场景编辑器中的显示来完成
    内容创作的核心工作区域,使用它选择和摆放场景图像、角色、特效、UI 等各类游戏元素。
    可以获得所见即所得的场景效果预览。
  说明
    场景视图的背景会显示一组标尺和网格,表示世界坐标系中各个点的位置信息。
    读数为(0,0)的点为场景中世界坐标系的原点。
    使用鼠标滚轮缩小视图显示时,每一个刻度代表100像素的距离。
    根据当前视图缩放尺度的不同,会在不同刻度上显示代表该点到原点距离的数字,单位都是像素。
    视图中的紫色线框表示场景中默认会显示的内容区域,这块区域的大小由设计分辨率决定。
    鼠标悬浮到场景中的节点上时,节点的约束框将会以灰色单线显示出来。
    节点在鼠标悬浮或选中状态下都能够看到约束框（灰色或蓝色的线框）,
    约束框的矩形区域表示节点的尺寸（size）属性大小。
    即使节点没有包含图像渲染组件（如Sprite）,也可以为节点设置size属性,
    而节点约束框以内的透明区域都可以被鼠标悬浮和点击选中。
    选中的节点周围将会有蓝色的线框提示节点的约束框。
    鼠标悬浮在节点上时,与节点的约束框同时显示的还有节点的名称
  相关操作
    鼠标右键拖拽：平移视图, 
    鼠标滚轮：以当前鼠标悬停位置为中心缩放视图。
    按住鼠标左键并拖拽,框选节点;
    选中多个节点后,进行的任何变换操作都会同时作用于所有选中的节点。
  快捷键
    W    激活移动变换工具
    E    激活旋转变换工具
    R    激活缩放变换工具
    T    激活矩形变换工具
Node_Tree,层级管理器：用树状列表形式展示场景中的所有节点和他们的层级关系
  PS：可直接将资源管理器中的图像拖动到层级管理器上「节点会自动以贴图资源文件名来命名」,
    同级后序节点的渲染顺序会在其前节点后「显示在上层」,子节点也永远显示在父节点上层,
    可随时调整节点的层级顺序和关系来控制显示顺序;
    点击来选中节点,被选中的节点会以蓝底色高亮显示。
    当前选中的节点会在场景编辑器中显示蓝色边框,并更新属性检查器中的内容。
  创建节点
    PS：在层级管理器中有两种方法可以创建节点：
    点击左上角的 + 按钮,或右键点击鼠标并进入右键菜单中的创建节点子菜单。
    从资源管理器中拖拽图片、字体或粒子等资源到层级管理器中。
Properties,属性检查器：查看并编辑当前选中节点的组件属性的工作区域 
  PS：
  相关操作 
    为节点添加组件功能: 点击添加组件按钮,从类别中选择相应的组件即可
    快捷操作
      为节点添加脚本组件: 将js文件拖到该面板,即将当前节点和脚本进行绑定
        然后再在面板中指定脚本properties中引入的其他节点或属性
  Node   节点,节点组件 
    Anchor   锚,默认在节点中心,可改变Anchor的X、Y值来改变其位置
    Design Resolution 规定了游戏的设计分辨率
    Fit Height和Fit Width规定了在不同尺寸的屏幕上运行时,将如何缩放节点以适配不同的分辨率
  Widget 对齐挂件,布局组件,实现多分辨率自适应排版 
    PS：能使当前节点自动对齐到父物体的任意位置,或者约束尺寸,让游戏适配不同分辨率
      对齐挂件的脚本接口请参考Widget API
    Position布局
      默认使用px,可使用百分比﹪
      若左右同时对齐,或者上下同时对齐,那么在相应方向上的尺寸就会被拉伸;
      Top    对齐上边界,用于设定当前节点的上边界和父物体的上边界之间的距离
      Bottom 对齐下边界,用于设定当前节点的下边界和父物体的下边界之间的距离
      Left   对齐左边界,用于设定当前节点的左边界和父物体的左边界之间的距离
      Right  对齐右边界,用于设定当前节点的右边界和父物体的右边界之间的距离
    HorizontalCenter 水平方向居中 
    VerticalCenter   竖直方向居中 
    Target    对齐目标,指定对齐参照的节点,未指定时默认使用父节点
    AlignOnce 默认为true,是否仅在组件初始化时进行一次对齐
      设为 false 时,每帧都会对当前 Widget 组件执行对齐逻辑「对性能有较大损耗！」
      组件所在节点的位置和尺寸属性可能会被限制,不能通过 API 或动画系统自由修改。
      因为通过 Widget 对齐是在每帧的最后阶段进行处理的,
      因此对 Widget 组件中已经设置了对齐的相关属性进行设置,
      最后都会被 Widget 组件本身的更新所重置。
      若需要同时满足对齐策略和可以在运行时改变位置和尺寸的需要,可以通过以下两种方式实现：
        在初始化时自动完成对齐,然后就可以通过 API 或动画系统对 UI 进行移动变换
        通过调用 Widget 组件的对齐边距 API,包括 top, bottom, left, right,
        直接修改 Widget 所在节点的位置或某一轴向的拉伸。
        这些属性也可以在动画编辑器中添加相应关键帧,保证对齐的同时实现各种丰富的 UI 动画。
  Spirte 精灵,场景图像组件            「Spirte节点所属属性」 
    PS：游戏中最常见的显示图像的方式;
      在面板中添加 Sprite 组件,就可以在场景中显示项目资源中的图片;
      只有图片类型的节点才能添加该组件
    Atlas        显示图片资源「spriteFrame」所属的图集资源 
      若拖拽的 SpriteFrame 资源是包含在一个 Atlas 图集资源中,
      那么 Sprite 的Atlas属性也会被一起设置。
      之后可点击Atlas属性的选择按钮来从该 Atlas 中挑选 SpriteFrame 指定给 Sprite;
    Sprite Frame 渲染Sprite使用的图片资源 
      可从资源管理器中拖拽 Texture 或 SpriteFrame 类型的资源到该属性引用中,
      即可通过Sprite组件显示资源图像;
    Type         渲染模式
      Simple 普通
        按照原始图片资源样子渲染 Sprite,在这个模式下一般不会手动修改节点的尺寸,
        保证场景中显示的图像和美术人员生产的图片比例一致。
      Sliced 九宫格
        图像将被分割成九宫格,并按照一定规则进行缩放以适应可随意设置的尺寸(size)。
        通常用于 UI 元素,或将缩放不影响质量的图片制作成九宫格图来节省游戏资源空间。
        详细信息请阅读使用 Sprite 编辑器制作九宫格图像一节。
      Tiled  平铺
        当 Sprite 的尺寸增大时,图像不会被拉伸,而是会按照原始图片的大小不断重复,
        就像平铺瓦片一样将原始图片铺满整个 Sprite 规定的大小;
      Filled 填充
        PS：根据原点和填充模式的设置,按照一定的方向和比例绘制原始图片的一部分; 
          Type 属性选择填充模式后,会出现一组新的属性可供配置;
          经常用于进度条的动态展示;
        Fill Type  填充类型选择
        HORIZONTAL 横向填充
        VERTICAL   纵向填充
        RADIAL     扇形填充
        Fill Start  填充起始位置的标准化数值「从 0 ~ 1,表示填充总量的百分比」
          选择横向填充时,Fill Start 设为 0,就会从图像最左边开始填充
        Fill Range  填充范围的标准化数值「0 ~ 1 之间」
          设为 1,就会填充最多整个原始图像的范围。
          在 HORIZONTAL 和 VERTICAL 这两种填充类型下,
            Fill Start 设置的数值将影响填充总量,
            若 Fill Start 设为 0.5,那么即使 Fill Range 设为 1.0,
            实际填充的范围也仍然只有 Sprite 总大小的一半。
          而 RADIAL 类型中 Fill Start 只决定开始填充的方向,
            Fill Start 为 0 时,从 x 轴正方向开始填充,
            Fill Range 决定填充总量,值为 1 时将填充整个圆形。
            Fill Range 为正值时逆时针填充,为负值时顺时针填充。
        Fill Center 填充中心点,只有选择了 RADIAL 类型才会出现这个属性
          决定扇形填充时会环绕 Sprite 上的哪个点,坐标系和设置 Anchor 锚点 一样
    Size Mode    指定 Sprite 的尺寸
      PS：手动修改size属性后,Size Mode会被自动设置为Custom,除非再次指定为前两种尺寸;
      Trimmed  使用原始图片资源裁剪透明像素后的尺寸
      Raw      使用原始图片未经裁剪的尺寸
      Custom   自定义尺寸
        用户在使用 矩形变换工具 拖拽改变节点的尺寸, 或通过修改 Size 属性,
        或在脚本中修改 width 或 height 后,都会自动将 Size Mode 设为 CUSTOM。
        表示用户将自己决定节点的尺寸,而不需要考虑原始图片的大小。      
    Trimmed Mode 是否渲染原始图像周围的透明像素区域
      详情请参考图像资源的自动剪裁。
    Src Blend Factor 当前图像混合模式
    Dst Blend Factor 背景图像混合模式
      和Src Blend Factor属性共同作用,可以将前景和背景 Sprite 用不同的方式混合渲染,
      效果预览可以参考 glBlendFunc Tool
    Trim   勾选后将在渲染 Sprite 图像时去除图像周围的透明像素
      取消勾选,Sprite 节点的约束框会包括透明像素的部分。
  Label  文本,文本组件                「Label节点所属属性」 
    PS：用来显示一段文字,文字可以是系统字体,TrueType 字体或者 BMFont 字体和艺术数字;
      Label 还具有排版功能;
    String           文本内容字符串
    Horizontal Align 文本的水平对齐方式 「LEFT,CENTER 和 RIGHT」
    Vertical Align   文本的垂直对齐方式 「TOP,CENTER 和 BOTTOM」
    Font Size        文本字体大小
    Line Height      文本的行高
    Overflow         文本的排版方式
      CLAMP         文字尺寸不会根据 Bounding Box 的大小进行缩放
        Wrap Text 关闭的情况下,按照正常文字排列,超出 Bounding Box 的部分将不会显示。
        Wrap Text 开启的情况下,会试图将本行超出范围的文字换行到下一行。 
        若纵向空间也不够时,也会隐藏无法完整显示的文字。
      SHRINK        文字尺寸会根据 Bounding Box 大小进行自动缩放
        不会自动放大,最大显示 Font Size 规定的尺寸,
        Wrap Text 开启时,当宽度不足时会优先将文字换到下一行, 
        若换行后还无法完整显示,则会将文字进行自动适配 Bounding Box 的大小。 
        若 Wrap Text 关闭时,则直接按照当前文字进行排版, 若超出边界则会进行自动缩放。
      RESIZE_HEIGHT 文本的 Bounding Box 会根据文字排版进行适配
        这个状态下用户无法手动修改文本的高度,文本的高度由内部算法自动计算出来。
    Enable Wrap Text 是否开启文本换行
    Font             指定文本渲染需要的字体文件, 若使用系统字体,则此属性可以为空
      可通过拖拽 TTF 字体文件和 BMFont 字体文件来修改渲染的字体类型;
      若不想继续使用字体文件,可以通过勾选Use System Font来重新启用系统字体
      使用艺术数字字体需要创建艺术数字资源,参考链接中的文档设置好艺术数字资源的属性之后,
      就可以像使用 BMFont 资源一样来使用艺术数字了。
    Use System Font  布尔值,是否使用系统字体
    BMFont 与 UI 合图自动批处理 
      从 Creator 1.4 版本开始, BMFont 支持与 UI 一起合图进行批量渲染。 
      理论上, 若你的游戏 UI 没有使用系统字体或者 TTF 字体,
      并且所有的 UI 图片资源都可以合在一张图上,
      那么 UI 是可以只用一个 Draw Call 来完成的。 
      更多关于 BMFont 与 UI 合图自动批处理的内容,请参考 BMFont 与 UI 合图自动批处理    
  Layout 一种容器组件,容器内子节点布局 「Layout节点所属属性」 
    PS：方便制作列表、翻页等功能
    Type       布局类型 
      NONE       默认值,表示容器不会修改子节点的大小和位置 
        当用户手动摆放子节点时,容器会以能够容纳所有子节点的最小矩形区域作为自身的大小
      HORIZONTAL 水平
      VERTICAL   垂直
      GRID       网格布局
        Cell Size   指定网格容器里面排版元素的大小
        Start Axis  指定网格容器里面元素排版指定的起始方向轴
    ResizeMode 缩放模式 
      NONE      子节点和容器的大小变化互不影响
      CONTAINER 容器变化,容器的大小会随着子节点的大小变化
      CHILDREN  内容变化,子节点大小会随着容器的大小而变化
    Padding边距 
      PaddingLeft   子节点相对于容器左边框的距离 
      PaddingRight  子节点相对于容器右边框的距离 
      PaddingTop    子节点相对于容器上边框的距离 
      PaddingBottom 子节点相对于容器下边框的距离 
    SpacingX  子节点间水平方向上的间距
    SpacingY  子节点间垂直方向上的间距
    Horizontal Direction 子节点水平排列方向 
      当容器为 Grid 类型时,此属性和 Start Axis 属性一起决定 Grid 布局元素的起始水平排列方向。
    Vertical Direction   子节点垂直排列方向 
      当容器为 Grid 类型时,此属性和 Start Axis 属性一起决定 Grid 布局元素的起始垂直排列方向。
  ScrollView  一种带滚动功能的容器     「ScrollView节点所属属性」
    PS：提供在有限的显示区域内浏览更多内容的一种方式;
      通常 ScrollView 会与 Mask组件配合使用,
      同时也可以添加ScrollBar组件来显示浏览内容的位置;
      滚动视图的脚本接口请参考ScrollView API;
      ScrollView 组件必须有指定的 content 节点才能起作用,
      通过指定滚动方向和 content 节点在此方向上的长度来计算滚动时的位置信息,
      Content 节点也可以通过UIWidget设置自动 resize。
    content    节点引用,用来创建 ScrollView 的可滚动内容 
      通常这可能是一个包含一张巨大图片的节点
    Horizontal 开启横向滚动
    Vertical   开启纵向滚动
    Inertia    开启滚动惯性
    Brake      滚动减速系数,范围 0-1 
      1   则立马停止滚动
      0   则会一直滚动到 content 的边界
    Elastic    开启滚动回弹
    Bounce Duration      回弹持续时间,范围 0-10,0 表示立即反弹
    Horizontal ScrollBar 节点引用,水平滚动条,显示content在水平方向上的位置 
    Vertical ScrollBar   节点引用,垂直滚动条,显示 content 在垂直方向上的位置
    Scroll Events        列表类型,默认为空 
      用户添加的每一个事件由节点引用,组件名称和一个响应函数组成
      详情见 'Scrollview 事件' 章节
    Cancel InnerEvents   滚动不触发子节点上的触摸事件
    ScrollView 事件 
      Target    带有脚本组件的节点。
      Component 脚本组件名称。
      Handle    指定一个回调函数,当 ScrollView 的事件发生的时候会调用此函数
      CustomEventData 用户指定任意的字符串作为事件回调的最后一个参数传入。
      Scrollview事件回调有两个参数
        第一个参数是 ScrollView 本身,第二个参数是 ScrollView 的事件类型。
    通常一个 ScrollView 的节点树：
      ScrollView
        view        // 可见区域
          content   // 显示内容,一般比显示区域大
            item    
            item
            ...
        ScrollBar
          bar
    通过脚本代码添加回调 
      方法一 添加的事件回调和使用编辑器添加的事件回调是一样的,通过代码添加, 
        需要首先构造一个 cc.Component.EventHandler 对象,
        然后设置好对应的 target, component, handler 和 customEventData 参数。
        //here is your component file, file name = MyComponent.js 
        cc.Class({
          extends: cc.Component,
          properties: {},
          
          onLoad: function () {
            var scrollViewEventHandler = new cc.Component.EventHandler();
            scrollViewEventHandler.target = this.node; //这个 node 节点是你的事件处理代码组件所属的节点
            scrollViewEventHandler.component = "MyComponent";//这个是代码文件名
            scrollViewEventHandler.handler = "callback";
            scrollViewEventHandler.customEventData = "foobar";
            
            var scrollview = node.getComponent(cc.ScrollView);
            scrollview.scrollEvents.push(scrollViewEventHandler);
          },
          
          //注意参数的顺序和类型是固定的
          callback: function (scrollview, eventType, customEventData) {
            //这里 scrollview 是一个 Scrollview 组件对象实例
            //这里的 eventType === cc.ScrollView.EventType enum 里面的值
            //这里的 customEventData 参数就等于你之前设置的 "foobar"
          }
        });
      方法二 通过 scrollview.node.on('scroll-to-top', ...) 的方式来添加
        //假设我们在一个组件的 onLoad 方法里面添加事件处理回调,在 callback 函数中进行事件处理:
        cc.Class({
          extends: cc.Component,
          
          
          properties: {
            scrollview: cc.ScrollView
          },
          
          onLoad: function () {
            this.scrollview.node.on('scroll-to-top', this.callback, this);
          },
          
          callback: function (event) {
            //这里的 event 是一个 EventCustom 对象,你可以通过 event.detail 获取 ScrollView 组件
            var scrollview = event.detail;
            //do whatever you want with scrollview
            //另外,注意这种方式注册的事件,也无法传递 customEventData
          }
        });
        同样的,你也可以注册 'scrolling', 'touch-up' , 'scrolling' 等事件,
        这些事件的回调函数的参数与 'scroll-to-top' 的参数一致。
  ScrollBar   滚动条组件,通过拖动滑块滚动节点  
    PS：与Slider组件类似,但是它主要是用于滚动而 Slider 则用来设置数值。
    Handle    滑动块
      长度/宽度会根据 ScrollView 的 content 的大小和实际显示区域的大小来计算
    Direction 滚动方向
    Enable Auto Hide 开启自动隐藏
      若开启了,那么在 ScrollBar 显示后的Auto Hide Time时间内会自动消失。
    Auto Hide Time   自动隐藏时间,需配合设置Enable Auto Hide
  属性检查器面板从上到下的排布：
  节点激活开关和节点名称
    左上角的复选框表示节点的激活状态, 
    使用节点处于非激活状态时,节点上所有图像渲染相关的组件都会被关闭,
    整个节点包括子节点就会被有效的隐藏。
  Node,节点属性
    PS：修改节点的属性通常可以立刻在场景编辑器中看到节点的外观或位置变化
    Position,位置
    Rotation,旋转
    Scale,缩放
    Size,尺寸
    Anchor,锚点
    Color,颜色
    Opacity,不透明度
  组件属性
    PS：节点上挂载的所有组件和组件的属性。
      用户通过脚本创建的组件,其属性是由脚本声明的。
      不同类型的属性在属性检查器中有不同的控件外观和编辑方式。
    属性编辑 
      属性是组件脚本中声明的公开并可被序列化存储在场景和动画数据中的变量。
      通过属性检查器我们可以快捷的修改属性设置,达到不需要编程就可以调整游戏数据和玩法的目的。
    属性类型 
      PS：通常可以根据变量使用内存位置不同将属性分为值类型和引用类型两大类。
      值类型属性:包括数字、字符串、枚举等简单的占用很少内存的变量类型：
        数值（Number）：可以直接使用键盘输入,也可以按输入框旁边的上下箭头逐步增减属性值。
        向量（Vec2）：向量的控件是两个数值输入组合在一起,并且输入框上会以x,y标识每个数值对应的子属性名。
        字符串（String）：直接在文本框里用键盘输入字符串,字符串输入控件分为单行和多行两种,多行文本框可以按回车换行。
        布尔（Boolean）：以复选框的形式来编辑,选中状态表示属性值为true,非选中状态表示false。
        枚举（Enum）：以下拉菜单的形式编辑,点击枚举菜单,然后从弹出的菜单列表里选择一项,即可完成枚举值的修改。
        颜色（Color）：点击颜色属性预览框,会弹出颜色选择器窗口,在这个窗口里可以用鼠标直接点选需要的颜色,或在下面的 RGBA 颜色输入框中直接输入指定的颜色。点击颜色选择器窗口以外的任何位置会关闭窗口并以最后选定的颜色作为属性颜色。
      引用类型属性
        PS：引用类型包括更复杂的对象,比如节点、组件或资源。
          和值类型各式各样的编辑方式不同,
          引用类型通常只有一种编辑方式：拖拽节点或资源到属性栏中。
          引用类型的属性在初始化后会显示None,因为无法通过脚本为引用类型的属性设置初始值。
          这时可以根据属性的类型将相应类型的节点或资源拖拽上去,即可完成引用赋值。
        需要拖拽节点来赋值的属性栏上会显示绿色的标签,
          标签上可能会显示Node, 表示任意节点都可以拖拽上去,
          或者标签显示组件名如Sprite,Animation等,这时需要拖拽挂载了相应组件的节点才行。
        需要拖拽资源赋值的属性栏上会显示黄色的标签,
          标签上显示的是资源的类型,如sprite-frame,prefab,font等。
          只要从资源管理器中拖拽相应类型的资源过来就可以完成赋值。
          脚本文件也是一种资源,组件使用的脚本资源引用属性也是用黄色标签表示的。
Console,控制台
  PS：控制台会显示报错、警告或其他编辑器和引擎生成的日志信息。
    不同重要级别的信息会以不同颜色显示：
    Log,日志： 灰色文字,通常用来显示正在进行的操作。
    Info,提示：蓝色文字,用来显示重要提示信息。
    Success,成功：绿色文字,表示当前执行的操作已成功完成。
    Warn,警告：   黄色文字,用来提示用户最好进行处理的异常情况,但不处理也不会影响运行。
    Error,报错：  红色文字,表示出现了严重错误,必须解决才能进行下一步操作或运行游戏。
  clear,清除  清除控制台面板中的所有当前信息。
  filter,过滤输入  根据输入的文本过滤控制台中的信息
    若勾选了旁边的Regex,输入的文本会被当做正则表达式来匹配文本。
  collapse,合并同类信息  该选项处于激活状态时,相同而重复的信息会被合并成一条,
    在信息旁边会以黄色数字提示有多少条同类信息被合并了。    
动画编辑器
--------------------------------------------------------------------------------
UI 系统 
  ◆渲染节点
  Sprite         精灵图,场景图像
  Sprite         单色
  Label          文字节点
  RichText       富文本
  ParticleSystem 粒子
  TiledMap       地图
  ◆UI节点 
  Layout      自动布局
  Buttom      按钮
  Canvas      画布
  ScrollView  滚动视图
  Slider      滑动器
  PageView    页面视图
  ProgressBar 进度条
  Toggle      复选按钮
  ToggleGroup 单选按钮
  EditBox     输入框
  VideoPlayer 播放器
  WebView     网页视图
  
  ScrollView 滚动视图
  Prefab 复用列表内容
--------------------------------------------------------------------------------
构建打包发布
--------------------------------------------------------------------------------
动画 
  动画根节点
序列帧动画
曲线动画
运行时自动播放动画















